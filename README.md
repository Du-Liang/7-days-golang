# 7天掌握go语言助你拿高薪

- [语言介绍](#语言介绍)
  * [语言的起源](#语言的起源)
  * [语言的特性](#语言的特性)
  * [搭建编译环境](#搭建编译环境)
  * [Hello World](#hello-world)
- [语言基础](#语言基础)
  * [常量与变量](#常量与变量)
  * [整型和浮点型](#整型和浮点型)
  * [字符串](#字符串)
  * [字符型](#字符型)
  * [数组和切片](#数组和切片)
  * [包](#包)
- [语言顺序编程](#语言顺序编程)
  * [流程控制](#控制流程)
  * [函数](#函数)
  * [类型转换](#类型转换)
  * [类型断言](#类型断言)
  * [error](#error)
  * [defer和panic](#defer和panic)
- [面向对象编程](#面向对象编程)
  * [自定义类型和结构体](#自定义类型和结构体)
  * [方法](#方法)
  * [组合](#组合)
  * [接口](#接口)
- [并发编程](#并发编程)
  * [并行与并发](#并行与并发)
  * [协程](#协程)
  * [groutine](#groutine)
  * [channel](#channel)
  * [select](#select)

## 语言介绍
### 语言的起源
### 语言的特性
### 搭建编译环境
### Hello World

```golang
package main

import "fmt"

func main() {
	fmt.Println("Hello World")
}
```
## 语言基础

在这里我想先和大家普及一个观念就是，编程的本质可以理解为就是在计算，否则为什么我们的电脑又叫做计算机的原因。那它到底又是在计算什么呢？这也就是接下来要和大家一起探讨的问题。

### 常量与变量

在声明完之后可以被改变的量，我们称之为常量；不能被改变的量，我们称之为变量。

给大家举两个例子：

常量：

```golang
const str1 string = "hello world"
```

先解释一下上面那句话是什么意思吧，我们生命了一个名为str1的string类型的常量，并非它赋值为"hello world"，这里需要注意的是常量声明完之后就必须要附上初始值，否则在编译的时候程序就会出错。

常量的关键字是**const**，只要加上这个关键字，str1就为常量了。

变量

```golang

var str2 string = "hello world"

str2 := "hello world"

var str2 string
str2 = "hello world"

```
在上面的代码中，我用三种形式声明了变量，并赋上了值。

变量有三种声明方式：
1. 第一种与声明常量时一样，显示声明了变量的数据类型为**string**，然后赋值上"hello world"；
2. 第二种使用**:=**的方式声明变量，通过这种方法golang的编译器可以自动推断出变量的数据类型;
3. 第三种其实是第一种方式的分步法，写上这种方式是为了突出变量和常量的区别，**常量声明完之后就必须要附上初始值**。

在例子中由于篇幅有限，我只使用了string类型声明常量，读者可以自己做实验，来试验一下变得数据类型。

### 整型与浮点型

整型就是不带小数点的数字，浮点型则是与它相反。

golang 中的整型分为 无符号(uint)和有符号(int)两种。无符号的意思是这它只能表示正数，有符号就是与之相反。

无符号数声明如下：

```golang
func main() {
	var num1 uint
	var num2 uint8
	var num3 uint16
	var num4 uint32
	var num5 uint64
}
```

有符号数声明如下：

```golang
func main() {
	var num1 int
	var num2 int8
	var num3 int16
	var num4 int32
	var num5 int64
}
```

这里我上补充说明一点，凡是使用**:=**进行隐式声明的变量，编译器都会自动推断为有符号数类型。

### 字符串

一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，但是通常是用来包含可读的文本，字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码表上的字符时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。

UTF-8 是一种被广泛使用的编码格式，是文本文件的标准编码，其中包括 XML 和 JSON 在内也都使用该编码。由于该编码对占用字节长度的不定性，在Go语言中字符串也可能根据需要占用 1 至 4 个字节，这与其它编程语言如 C++、Java 或者 Python 不同（Java 始终使用 2 个字节）。Go语言这样做不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。

字符串是一种值类型，且值不可变，即创建某个文本后将无法再次修改这个文本的内容，更深入地讲，字符串是字节的定长数组。

以下就是定义字符串的方法

```golang
package main

import (
    "fmt"
)

func main() {
    var str = "C语言中文网\nGo语言教程"
    fmt.Println(str)
}
```

### 字符型

字符串中的每一个元素叫做“字符”，在遍历或者单个获取字符串元素时可以获得字符。

Go语言的字符有以下两种：
* 一种是 uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符。
* 另一种是 rune 类型，代表一个 UTF-8 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型等价于 int32 类型。

byte 类型是 uint8 的别名，对于只占用 1 个字节的传统 ASCII 编码的字符来说，完全没有问题，例如 var ch byte = 'A'，字符使用单引号括起来。

在 ASCII 码表中，A 的值是 65，使用 16 进制表示则为 41，所以下面的写法是等效的：
```
var ch byte = 65 或 var ch byte = '\x41'      //（\x 总是紧跟着长度为 2 的 16 进制数）
```

另外一种可能的写法是\后面紧跟着长度为 3 的八进制数，例如 \377。

Go语言同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者 runes，并在内存中使用 int 来表示。在文档中，一般使用格式 U+hhhh 来表示，其中 h 表示一个 16 进制数。

在书写 Unicode 字符时，需要在 16 进制数之前加上前缀\u或者\U。因为 Unicode 至少占用 2 个字节，所以我们使用 int16 或者 int 类型来表示。如果需要使用到 4 字节，则使用\u前缀，如果需要使用到 8 个字节，则使用\U前缀。

```golang
var ch int = '\u0041'
var ch2 int = '\u03B2'
var ch3 int = '\U00101234'
fmt.Printf("%d - %d - %d\n", ch, ch2, ch3) // integer
fmt.Printf("%c - %c - %c\n", ch, ch2, ch3) // character
fmt.Printf("%X - %X - %X\n", ch, ch2, ch3) // UTF-8 bytes
fmt.Printf("%U - %U - %U", ch, ch2, ch3)   // UTF-8 code point
```

格式化说明符**%c**用于表示字符，当和字符配合使用时，**%v**或**%d**会输出用于表示该字符的整数，**%U**输出格式为 U+hhhh 的字符串。

Unicode 包中内置了一些用于测试字符的函数，这些函数的返回值都是一个布尔值，如下所示（其中 ch 代表字符）：
* 判断是否为字母：unicode.IsLetter(ch)
* 判断是否为数字：unicode.IsDigit(ch)
* 判断是否为空白符号：unicode.IsSpace(ch)

### 数组和切片

golang中的**数组**是一种由固定长度和固定对象类型所组成的数据类型。例如下面：
```golang
var a [4]int
```
a是一个拥有4个int类型元素的数组。当a一旦被声明之后，元素个数就被固定了下来，在a这个变量的生命周期之内，元素个数不会发生变化。而此时a的类型就是[4]int，如果同时存在一个b变量，为[5]int。即便两个变量仅仅相差一个元素，那么在内存中也占据着完全不同的地址分配单元，a和b就是两个完全不同的数据类型。在golang中，数组一旦被定义了，那么其内部的元素就完成了初始化。也就是时候a[0]等于0。
在golang当中，一个数组就是一个数据实体对象。在golang当使用a时，就代表再使用a这个数组。而在C中，当使用a时，则代表着这个数组第一个元素的指针。

数组声明时候方括号内需要写明数组的长度或者使用(...)符号自动计算长度，切片不需要指定数组的长度。比较规范的声明方式是使用make，大致有两种方式
* 只指定长度，这个时候切片长度和容量相同；
* 同时指定切片的长度和容量。

```golang
var s1 = make([]byte, 5)
var s2 = make([]byte, 5, 10)
```

由于切片是 **引用类型** ，因此当引用改变其中元素的值时候，其他的所有引用都会改变该值。例如
```
var a = []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
s1 := a[:4]
s2 := a[3:7]
fmt.Println(s1)
fmt.Println(s2)
s1[3] = 100
fmt.Println(s1)
fmt.Println(s2)
```
结果是：

[1 2 3 4]

[4 5 6 7]

[1 2 3 100]

[100 5 6 7]

### 包
Go语言是使用包来组织源代码的，包（package）是多个 Go 源码的集合，是一种高级的代码复用方案。Go语言中为我们提供了很多内置包，如 fmt、os、io 等。

任何源代码文件必须属于某个包，同时源码文件的第一行有效代码必须是package pacakgeName 语句，通过该语句声明自己所在的包。

#### 包的基本概念
Go语言的包借助了目录树的组织形式，一般包的名称就是其源文件所在目录的名称，虽然Go语言没有强制要求包名必须和其所在的目录名同名，但还是建议包名和所在目录同名，这样结构更清晰。

包可以定义在很深的目录中，包名的定义是不包括目录路径的，但是包在引用时一般使用全路径引用。比如在GOPATH/src/a/b/ 下定义一个包 c。在包 c 的源码中只需声明为package c，而不是声明为package a/b/c，但是在导入 c 包时，需要带上路径，例如import "a/b/c"。

包的习惯用法：
* 包名一般是小写的，使用一个简短且有意义的名称。
* 包名一般要和所在的目录同名，也可以不同，包名中不能包含- 等特殊符号。
* 包一般使用域名作为目录名称，这样能保证包名的唯一性，比如 GitHub 项目的包一般会放到GOPATH/src/github.com/userName/projectName 目录下。
* 包名为 main 的包为应用程序的入口包，编译不包含 main 包的源码文件时不会得到可执行文件。
* 一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。

#### 包的导入
要在代码中引用其他包的内容，需要使用 import 关键字导入使用的包。具体语法如下：
```golang
import "包的路径"
```

注意事项：
import 导入语句通常放在源码文件开头包声明语句的下面；
导入的包名需要使用双引号包裹起来；
包名是从GOPATH/src/ 后开始计算的，使用/ 进行路径分隔。

## 语言顺序编程
### 流程控制
### 函数
### 类型转换
### 类型断言
### error
### defer和panic
## 面向对象编程
### 自定义类型和结构体
### 方法
### 组合
### 接口
## 并发编程
### 并行与并发
### 协程
### groutine
### channel
### select
